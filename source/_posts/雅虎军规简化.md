---
title: 雅虎军规简化
date: 2018-01-05 15:25:23
tags: 前端性能优化
categories: 前端
---

## 尽量减少HTTP请求次数
  1. **合并文件**：合并文件就是通过把所有对的脚本放在一个文件中来减少HTTP请求的方法，例如把多个js文件合并为一个文件，或者多个css合并为一个文件。
  2. **CSS Sprites**：CSS Spriets是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的**background-image**和**background-position**属性来显示图片的不同部分。
  3. **内联图像**：内联图像是使用 data:URL scheme的方法把图像数据加载页面中，这可能会增大页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时有避免增加页面文件的大小。

## 减少DNS查找次数
域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入 www.baidu.com 时，DNS解析服务器会返回这个域名对应的IP地址。DNS解析的过程中同样也是需要时间的，一般情况下会返回给定的域名，对应的IP地址会花费20到120毫秒的时间，而且在**这个过程中浏览器什么都不会做一直到DNS查找完毕。**

在网页体验中我们常会遇到这种情况，即在调用百度联盟、谷歌联盟以及当前网页所在域名外的域名文件时会遇到请求延时非常严重的情况。因为DNS解析速度很可能是造成资源延时的最大原因。
**前端可以在页面header中添加了以下代码（用以DNS预解析）**
```html
<!--用meta信息来告知浏览器, 当前页面要做DNS预解析-->
<meta http-equiv="x-dns-prefetch-control" content="on" />
<!--在页面header中使用link标签来强制对DNS预解析-->
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
<link rel="dns-prefetch" href="http://nsclick.baidu.com" />
<link rel="dns-prefetch" href="http://hm.baidu.com" />
<link rel="dns-prefetch" href="http://eiv.baidu.com" />
```
**注**：dns-prefetch 需慎用，多页面重复DNS预解析会增加重复DNS查询次数。

## 避免跳转
跳转是使用301和302代码实现的。下面是一个响应代码为301的HTTP头：
``` http
HTTP/1.1 301 Moved Permanently
Location: http://www.baidu.com
Content-Type: text/html
```
浏览器会把用户向到Location中指定的URL。头文件中所有信息再一次跳转中都是必需的，内容部分为空。不管他们的名称，301和302响应都是不会被缓存的，除非增加一个额外的选项头，如Expires或者Cache-Control来指定它缓存。

<meat />元素的刷新标签和JavaScript也可以实现URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。

但是要记住跳转会降低用户体验。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。

有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http: //astrology.yahoo.com/astrology 时，实际上返回的是一个包含301代码的跳转，它指向的是http://astrology.yahoo.com/astrology/ （注意末尾的斜杠）。在Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。

## 可缓存的AJAX
Ajax经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用Ajax并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于Ajax如何来使用。例如，在一个基于Web的Email客户端中，用户必须等待Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这很重要。

为了提高性能，优化Ajax响应是很重要的。提高Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看《Add an Expires or a Cache-Control Header》。其它的几条规则也同样适用于Ajax：
1. Gizp压缩
2. 减少DNS查找次数
3. 精简Javascript
4. 避免跳转
5. 配置Etags

让我们来看一个例子：一个Web2.0的Email客户端会使用Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过Email web应用程序后没有对地址薄作任何的修改，而且Ajax响应通过Expire或者Cacke-Control头来实现缓存，那么就可以直接从上一次的缓 存中读取地址薄了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如，&t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间戳就不变，则 从浏览器的缓存中加载从而减少了一次HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的URL和缓存响应并不匹配，浏览器就会重要请求更新 地址薄。

## 推迟加载内容
哪些内容是页面呈现时所必需首先加载的，哪些内容和结构可以稍后再加载。

把整个过程按照onload事件分隔成两部分，JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的JavaScript， 那么它 就以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载。

## 预加载
预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。

预加载的几种方法：
1. **无条件加载**：触发onload事件时，直接加载额外的页面内容。以Google.com为例，你可以看一下它的spirit image图像是怎样在onload中加载的。这个spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。
2. **有条件加载**：根据用户的操作来有根据的判断下用户下面可能去往的页面并相应的预加载内容。
3. **有预期的加载**：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可 能出在用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站 中利用浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。
4. **HTML5页面资源预加载(Link prefetch)写法** 
```html
<!-- 预加载整个页面 -->
<link rel="prefetch" href="http://www.baidu.com/" />

<!-- 预加载一个图片 -->
<link rel="prefetch" href=" http://www.baidu.com/logo.jpg " />

<!-- HTML5页面资源预加载/预读取(Link prefetch)功能是通过Link标记实现的，将rel属性指定为“prefetch”，
在href属性里指定要加载资源的地址。火狐浏览器里还提供了一种额外的属性支持： -->
<link rel="prefetch alternate stylesheet"  href="style.css" />
```
**注**： HTTPS协议资源下也可以使用prefetch。

## 减少DOM元素数量
一个复杂的页面意味着需要下载更多数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。所以尽量减少DOM数量。

## 根据域名划分页面内容
把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以 把用到的HTML内容和动态内容放在www.baidu.com上，而把页面各种组件（图片、脚本、CSS)分别存放在 img.baidu.com和img2.baidu.com上。

## 使iframe的数量最小
尽量减少使用iframe的数量。
优点：
1. 解决加载缓慢的第三方内容如图标和广告等的加载问题；
2. Security sandbox；
3. 并行加载脚本。

缺点：
1. 即时内容为空，加载也需要时间；
2. 会阻止页面加载；
3.  没有语意。

## 不要出现404错误
HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处
有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当 作JavaScript代码来执行。

## 使用内容分发网络
用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度
**CDN**：内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。

## 为文件头指定Expires或Cache-Control
这条守则包括两方面的内容：
1. **对于静态内容**：设置文件头过期时间Expires的值为“Never expire”(永不过期)。
2. **对于动态内容**：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求。

## Gzip压缩文件内容
网络中传输的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的宽带、互联网提供者于对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。

从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件的压缩格式：
```
Accept-Encoding:gzip,deflate
```
如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content-Encoding来返回给浏览器。
```
Content-Encoding：gzip
```
Gzip是目前最流行也是最有效的压缩方式。这是有GNU项目开发并通过RFC 1952来标准化。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。

服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行 压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小

Gzip大概可以减少70%的响应规模。Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。

## 配置ETag
Entity tags（Etags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供来一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号唯一的字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有ETag文件头的响应指定页面内容的ETag。

```http
HTTP/1.1 200 OK
Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT
ETag: “10c24bc-4ab-457e1c1f”
Content-Length: 12195
```
稍后，如果有浏览器要验证一个文件，它会使用 If-None-Match 文件头来把ETag传会给原始服务器。在这个例子中，如果ETag匹配，就会返回一个304状态码，这样就节省了12195字节的响应。
```http
GET /i/yahoo.gif HTTP/1.1
Host: www.baidu.com
If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
If-None-Match: “10c24bc-4ab-457e1c1f”
HTTP/1.1 304 Not Modified

```
ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证ETag就会不匹配，这种情况对使用服务器和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著减少多服务器间的文件验证冲突。

## 尽早刷新输出缓冲
当用户请求一个页面是，无论如果都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理 剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。

## 使用GET来完成AJAX请求
Yahoo！Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：
1. 首先发送文件头
2. 然后才发送数据

因此使用GET最为恰当，因为它只需要发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的数据时就不能 使用GET了

一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST

## 把样式表置于顶部
在研究Yahoo!的性能表现时，我们发现把样式表放到文档的<head />内部似乎会加快页面的下载速度。这是因为把样式表放到<head />内会使页面有步骤的加载显示。

把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘，用户不得不面对一个空白页面

## 避免使用CSS表达式（Expression）
CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：
```css
background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00″);
```
如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。 expression方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。

表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。

一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样 式属性必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。**如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能 会对你页面的性能产生影响。**

## 使用外部Javascript和CSS
很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢还是把它们放在页面本身之内呢？

在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。**内置在HTML文档中的 JavaScript和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说， 如果外部文件中的JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。**

## 消减JavaScript和CSS
精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。 在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。

除消减外部的脚本和样式表文件外，和代码块也可以并且应该进行消减。即使你用Gzip压缩 过脚本和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。

## 用\<link>代替@import
前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。
在IE中，页面底部@import和使用<link>作用是一样的，因此最好不要使用它。

## 避免使用滤镜
IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。

完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。

## 剔除重复脚本
在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在 重复引用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP 请求和无用的JavaScript运算，这降低了网站性能。

## 把脚本置于页面底部
脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本时，浏览器就不会同时下载其它文件了，即便是主机名不相同。

在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还会有作用域的问题。很多情况下，都会遇到这方面的问题。

## 减少DOM访问
使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：

1. 缓存已经访问过的有关元素；

2. 线下更新完节点之后再将它们添加到文档树中；

3. 避免使用JavaScript来修改页面布局。

## 开发智能事件处理程序
有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。

## 减小Cookie体积
HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。
1. 除去不必要得到cookie。
2. 使cookie体积尽量小以减少对用户响应的影响。
3. 注意在适应级别的域名上设置cookie以便使子域名不受影响。

## 对于页面内容使用无coockie域名
当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容

## 优化图像
图像压缩

## 优化CSS Spirite
在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；

Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；

便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，而 1000×1000就是100万像素。

## 不要在HTML中缩放图像

不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：
```html
<img width=”100″ height=”100″ src=”mycat.jpg” alt=”My Cat” />
```
那么你的图片（mycat.jpg）就应该是100×100像素而不是把一个500×500像素的图片缩小使用。

## favicon.ico要小而且可缓存
favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要 返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。

因此，为了减少favicon.ico带来的弊端，要做到：文件尽量地小，最好小于1K。

## 保持单个内容小于25K
这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重要。

## 打包组件成复合文本
把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone就不支持）